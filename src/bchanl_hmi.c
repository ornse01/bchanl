/*
 * bchanl_hmi.c
 *
 * Copyright (c) 2012 project bchan
 *
 * This software is provided 'as-is', without any express or implied
 * warranty. In no event will the authors be held liable for any damages
 * arising from the use of this software.
 *
 * Permission is granted to anyone to use this software for any purpose,
 * including commercial applications, and to alter it and redistribute it
 * freely, subject to the following restrictions:
 *
 * 1. The origin of this software must not be misrepresented; you must not
 *    claim that you wrote the original software. If you use this software
 *    in a product, an acknowledgment in the product documentation would be
 *    appreciated but is not required.
 *
 * 2. Altered source versions must be plainly marked as such, and must not be
 *    misrepresented as being the original software.
 *
 * 3. This notice may not be removed or altered from any source
 *    distribution.
 *
 */

/* This file is automatically generated. */

#include    "bchanl_hmi.h"
#include    "hmi/hmi_windowscroll.h"

#include	<bstdio.h>
#include	<bstdlib.h>
#include	<tcode.h>
#include	<tstring.h>
#include	<btron/btron.h>
#include	<btron/hmi.h>
#include	<btron/vobj.h>

#if 1
# define DP(arg) printf arg
# define DP_ER(msg, err) printf("%s (%d/%x)\n", msg, err>>16, err)
#else
# define DP(arg) /**/
# define DP_ER(msg, err) /**/
#endif

struct subjectwindow_t_ {
	UW flag;
	WID wid;
	GID gid;
	WID parent;
	RECT r;
	PAT bgpat;
	hmi_windowscroll_t wscr;
	WEVENT savedwev;
};

struct bbsmenuwindow_t_ {
	UW flag;
	WID wid;
	GID gid;
	WID parent;
	RECT r;
	PAT bgpat;
	hmi_windowscroll_t wscr;
	WEVENT savedwev;
};

struct subjectoptionwindow_t_ {
	UW flag;
	WID wid;
	GID gid;
	subjectwindow_t *parent;
	RECT r;
	PAT bgpat;
	TC title[256+1];
	WEVENT savedwev;
	struct {
		PAID id;
		W dnum;
		TC buf[1000+7+1];
		W buf_written;
		Bool appended;
		Bool nextaction;
	} filter;
	struct {
		PAID id;
		W dnum;
		SUBJECTOPTIONWINDOW_ORDERVALUE_T value;
	} order;
	struct {
		PAID id;
		W dnum;
		SUBJECTOPTIONWINDOW_ORDERBYVALUE_T value;
	} orderby;
};

struct registerexternalwindow_t_ {
	UW flag;
	WID wid;
	GID gid;
	WID parent;
	RECT r;
	PAT bgpat;
	TC title[256+1];
	WEVENT savedwev;
	struct {
		PAID id;
		
		TC buf[1000+7+1];
		W buf_written;
		Bool appended;
		Bool nextaction;
	} boradname;
	struct {
		PAID id;
		
		TC buf[1000+7+1];
		W buf_written;
		Bool appended;
		Bool nextaction;
	} url;
	struct {
		PAID id;
		
	} determine;
	struct {
		PAID id;
		
	} cancel;
};

struct externalbbswindow_t_ {
	UW flag;
	WID wid;
	GID gid;
	WID parent;
	RECT r;
	PAT bgpat;
	hmi_windowscroll_t wscr;
	TC title[256+1];
	WEVENT savedwev;
};

#define BCHANLHMI_FLAG_SWITCHBUTDN 0x00000001

struct bchanlhmi_t_ {
	WEVENT wev;
	bchanlhmievent_t evt;
	UW flag;
	subjectwindow_t *subjectwindow;
	bbsmenuwindow_t *bbsmenuwindow;
	subjectoptionwindow_t *subjectoptionwindow;
	registerexternalwindow_t *registerexternalwindow;
	externalbbswindow_t *externalbbswindow;
};

#define SUBJECTWINDOW_FLAG_DRAWREQUEST 0x00000001
#define SUBJECTWINDOW_FLAG_RSCROLLING 0x00000002
#define SUBJECTWINDOW_FLAG_BSCROLLING 0x00000004

#define subjectwindow_setflag(window, flagx) (window)->flag = (window)->flag | (flagx)
#define subjectwindow_clearflag(window, flagx) (window)->flag = (window)->flag & ~(flagx)
#define subjectwindow_issetflag(window, flagx) (((window)->flag & (flagx)) == 0 ? False : True)

EXPORT VOID subjectwindow_scrollbyvalue(subjectwindow_t *window, W dh, W dv)
{
	hmi_windowscroll_scrollworkrect(&window->wscr, dh, dv);
}

EXPORT W subjectwindow_setdrawrect(subjectwindow_t *window, W l, W t, W r, W b)
{
	return hmi_windowscroll_setdrawrect(&window->wscr, l, t, r, b);
}

EXPORT W subjectwindow_setworkrect(subjectwindow_t *window, W l, W t, W r, W b)
{
	return hmi_windowscroll_setworkrect(&window->wscr, l, t, r, b);
}

EXPORT W subjectwindow_scrollworkarea(subjectwindow_t *window, W dh, W dv)
{
	W err;
	err = wscr_wnd(window->wid, NULL, dh, dv, W_MOVE|W_RDSET);
	if (err < 0) {
		return err;
	}
	if ((err & W_RDSET) != 0) {
		subjectwindow_setflag(window, SUBJECTWINDOW_FLAG_DRAWREQUEST);
	}
	return 0;
}

EXPORT W subjectwindow_getworkrect(subjectwindow_t *window, RECT *r)
{
	return wget_wrk(window->wid, r);
}

EXPORT VOID subjectwindow_responsepasterequest(subjectwindow_t *window, W nak, PNT *pos)
{
	if (pos != NULL) {
		window->savedwev.r.r.p.rightbot.x = pos->x;
		window->savedwev.r.r.p.rightbot.y = pos->y;
	}
	wrsp_evt(&window->savedwev, nak);
}

EXPORT W subjectwindow_startredisp(subjectwindow_t *window, RECT *r)
{
	return wsta_dsp(window->wid, r, NULL);
}

EXPORT W subjectwindow_endredisp(subjectwindow_t *window)
{
	return wend_dsp(window->wid);
}

EXPORT W subjectwindow_eraseworkarea(subjectwindow_t *window, RECT *r)
{
	return wera_wnd(window->wid, r);
}

EXPORT W subjectwindow_requestredisp(subjectwindow_t *window)
{
	return wreq_dsp(window->wid);
}

EXPORT GID subjectwindow_startdrag(subjectwindow_t *window)
{
	return wsta_drg(window->wid, 0);
}

EXPORT W subjectwindow_getdrag(subjectwindow_t *window, PNT *pos, WID *wid, PNT *pos_butup)
{
	W etype;

	etype = wget_drg(pos, &window->savedwev);
	*wid = window->savedwev.s.wid;
	if (etype == EV_BUTUP) {
		*pos_butup = window->savedwev.s.pos;
	}

	return etype;
}

EXPORT VOID subjectwindow_enddrag(subjectwindow_t *window)
{
	wend_drg();
}

EXPORT GID subjectwindow_getGID(subjectwindow_t *window)
{
	return wget_gid(window->wid);
}

EXPORT WID subjectwindow_getWID(subjectwindow_t *window)
{
	return window->wid;
}

EXPORT W subjectwindow_settitle(subjectwindow_t *window, TC *title)
{
	return wset_tit(window->wid, -1, title, 0);
}

EXPORT Bool subjectwindow_isactive(subjectwindow_t *window)
{
	WID wid;
	wid = wget_act(NULL);
	if (window->wid == wid) {
		return True;
	}
	return False;
}

LOCAL VOID subjectwindow_butdnwork(subjectwindow_t *window, WEVENT *wev, bchanlhmievent_t *evt)
{
	evt->type = BCHANLHMIEVENT_TYPE_SUBJECTWINDOW_BUTDN;
	evt->data.subjectwindow_butdn.type = wchk_dck(wev->s.time);
	evt->data.subjectwindow_butdn.pos = wev->s.pos;
	memcpy(&window->savedwev, wev, sizeof(WEVENT));
}

LOCAL VOID subjectwindow_resize(subjectwindow_t *window, SIZE *sz)
{
	RECT work;
	Bool workchange = False;

	wget_wrk(window->wid, &work);
	if (work.c.left != 0) {
		work.c.left = 0;
		workchange = True;
	}
	if (work.c.top != 0) {
		work.c.top = 0;
		workchange = True;
	}
	wset_wrk(window->wid, &work);
	gset_vis(window->gid, work);

	if (workchange == True) {
		wera_wnd(window->wid, NULL);
		wreq_dsp(window->wid);
	}

	sz->v = work.c.bottom - work.c.top;
	sz->h = work.c.right - work.c.left;
}

LOCAL W subjectwindow_open(subjectwindow_t *window, TC *title)
{
	WID wid;

	if (window->wid > 0) {
		return 0;
	}

	wid = wopn_wnd(WA_STD|WA_SIZE|WA_HHDL|WA_VHDL|WA_BBAR|WA_RBAR, window->parent, &(window->r), NULL, 2, title, &window->bgpat, NULL);
	if (wid < 0) {
		DP_ER("wopn_wnd: subjectoption error", wid);
		return wid;
	}
	window->wid = wid;
	window->gid = wget_gid(wid);
	hmi_windowscroll_settarget(&window->wscr, wid);


	wreq_dsp(wid);

	return 0;
}

#define BBSMENUWINDOW_FLAG_DRAWREQUEST 0x00000001
#define BBSMENUWINDOW_FLAG_RSCROLLING 0x00000002
#define BBSMENUWINDOW_FLAG_BSCROLLING 0x00000004

#define bbsmenuwindow_setflag(window, flagx) (window)->flag = (window)->flag | (flagx)
#define bbsmenuwindow_clearflag(window, flagx) (window)->flag = (window)->flag & ~(flagx)
#define bbsmenuwindow_issetflag(window, flagx) (((window)->flag & (flagx)) == 0 ? False : True)

EXPORT VOID bbsmenuwindow_scrollbyvalue(bbsmenuwindow_t *window, W dh, W dv)
{
	hmi_windowscroll_scrollworkrect(&window->wscr, dh, dv);
}

EXPORT W bbsmenuwindow_setdrawrect(bbsmenuwindow_t *window, W l, W t, W r, W b)
{
	return hmi_windowscroll_setdrawrect(&window->wscr, l, t, r, b);
}

EXPORT W bbsmenuwindow_setworkrect(bbsmenuwindow_t *window, W l, W t, W r, W b)
{
	return hmi_windowscroll_setworkrect(&window->wscr, l, t, r, b);
}

EXPORT W bbsmenuwindow_scrollworkarea(bbsmenuwindow_t *window, W dh, W dv)
{
	W err;
	err = wscr_wnd(window->wid, NULL, dh, dv, W_MOVE|W_RDSET);
	if (err < 0) {
		return err;
	}
	if ((err & W_RDSET) != 0) {
		bbsmenuwindow_setflag(window, BBSMENUWINDOW_FLAG_DRAWREQUEST);
	}
	return 0;
}

EXPORT W bbsmenuwindow_getworkrect(bbsmenuwindow_t *window, RECT *r)
{
	return wget_wrk(window->wid, r);
}

EXPORT W bbsmenuwindow_startredisp(bbsmenuwindow_t *window, RECT *r)
{
	return wsta_dsp(window->wid, r, NULL);
}

EXPORT W bbsmenuwindow_endredisp(bbsmenuwindow_t *window)
{
	return wend_dsp(window->wid);
}

EXPORT W bbsmenuwindow_eraseworkarea(bbsmenuwindow_t *window, RECT *r)
{
	return wera_wnd(window->wid, r);
}

EXPORT W bbsmenuwindow_requestredisp(bbsmenuwindow_t *window)
{
	return wreq_dsp(window->wid);
}

EXPORT GID bbsmenuwindow_startdrag(bbsmenuwindow_t *window)
{
	return wsta_drg(window->wid, 0);
}

EXPORT W bbsmenuwindow_getdrag(bbsmenuwindow_t *window, PNT *pos, WID *wid, PNT *pos_butup)
{
	W etype;

	etype = wget_drg(pos, &window->savedwev);
	*wid = window->savedwev.s.wid;
	if (etype == EV_BUTUP) {
		*pos_butup = window->savedwev.s.pos;
	}

	return etype;
}

EXPORT VOID bbsmenuwindow_enddrag(bbsmenuwindow_t *window)
{
	wend_drg();
}

EXPORT GID bbsmenuwindow_getGID(bbsmenuwindow_t *window)
{
	return wget_gid(window->wid);
}

EXPORT WID bbsmenuwindow_getWID(bbsmenuwindow_t *window)
{
	return window->wid;
}

EXPORT W bbsmenuwindow_settitle(bbsmenuwindow_t *window, TC *title)
{
	return wset_tit(window->wid, -1, title, 0);
}

EXPORT Bool bbsmenuwindow_isactive(bbsmenuwindow_t *window)
{
	WID wid;
	wid = wget_act(NULL);
	if (window->wid == wid) {
		return True;
	}
	return False;
}

LOCAL VOID bbsmenuwindow_butdnwork(bbsmenuwindow_t *window, WEVENT *wev, bchanlhmievent_t *evt)
{
	evt->type = BCHANLHMIEVENT_TYPE_BBSMENUWINDOW_BUTDN;
	evt->data.bbsmenuwindow_butdn.type = wchk_dck(wev->s.time);
	evt->data.bbsmenuwindow_butdn.pos = wev->s.pos;
	memcpy(&window->savedwev, wev, sizeof(WEVENT));
}

LOCAL VOID bbsmenuwindow_resize(bbsmenuwindow_t *window, SIZE *sz)
{
	RECT work;
	Bool workchange = False;

	wget_wrk(window->wid, &work);
	if (work.c.left != 0) {
		work.c.left = 0;
		workchange = True;
	}
	if (work.c.top != 0) {
		work.c.top = 0;
		workchange = True;
	}
	wset_wrk(window->wid, &work);
	gset_vis(window->gid, work);

	if (workchange == True) {
		wera_wnd(window->wid, NULL);
		wreq_dsp(window->wid);
	}

	sz->v = work.c.bottom - work.c.top;
	sz->h = work.c.right - work.c.left;
}

LOCAL W bbsmenuwindow_open(bbsmenuwindow_t *window, TC *title)
{
	WID wid;

	if (window->wid > 0) {
		return 0;
	}

	wid = wopn_wnd(WA_STD|WA_SIZE|WA_HHDL|WA_VHDL|WA_BBAR|WA_RBAR, window->parent, &(window->r), NULL, 2, title, &window->bgpat, NULL);
	if (wid < 0) {
		DP_ER("wopn_wnd: subjectoption error", wid);
		return wid;
	}
	window->wid = wid;
	window->gid = wget_gid(wid);
	hmi_windowscroll_settarget(&window->wscr, wid);


	wreq_dsp(wid);

	return 0;
}

#define SUBJECTOPTIONWINDOW_FLAG_DRAWREQUEST 0x00000001
#define SUBJECTOPTIONWINDOW_FLAG_PARTS_OTHEREVENT 0x0000000f
#define SUBJECTOPTIONWINDOW_FLAG_PARTS_NEXTACTION 0x00000010

#define subjectoptionwindow_setflag(window, flagx) (window)->flag = (window)->flag | (flagx)
#define subjectoptionwindow_clearflag(window, flagx) (window)->flag = (window)->flag & ~(flagx)
#define subjectoptionwindow_issetflag(window, flagx) (((window)->flag & (flagx)) == 0 ? False : True)

EXPORT W subjectoptionwindow_setfiltertext(subjectoptionwindow_t *window, TC *str, W len)
{
	W cp_len;

	if (len < 1000) {
		cp_len = len;
	} else {
		cp_len = 1000;
	}
	memcpy(window->filter.buf+7, str, cp_len * sizeof(TC));
	window->filter.buf[7 + cp_len] = TNULL;
	window->filter.buf_written = cp_len;
	if (window->wid < 0) {
		return 0;
	}

	return cset_val(window->filter.id, cp_len, (W*)(window->filter.buf+7));
}

EXPORT W subjectoptionwindow_getfiltertext(subjectoptionwindow_t *window, TC *str, W len)
{
	W err, cp_len;

	if (window->wid > 0) {
		err = cget_val(window->filter.id, 1000, (W*)(window->filter.buf+7));
		if (err < 0) {
			return err;
		}
		window->filter.buf_written = err;
	}

	if (len < window->filter.buf_written) {
		cp_len = len;
	} else {
		cp_len = window->filter.buf_written;
	}
	memcpy(str, window->filter.buf + 7, cp_len * sizeof(TC));

	return cp_len;
}

EXPORT W subjectoptionwindow_cutfiltertext(subjectoptionwindow_t *window, TC *str, W len, Bool cut)
{
	W err, len0;

	len0 = ccut_txt(window->filter.id, len, str, cut == False ? 0 : 1);
	if (len0 < 0) {
		return len0;
	}

	if (cut != False) {
		err = cget_val(window->filter.id, 1000, (W*)(window->filter.buf+7));
		if (err < 0) {
			return err;
		}
		window->filter.buf_written = err;
		return len0;
	}

	return len0;
}

EXPORT W subjectoptionwindow_insertfiltertext(subjectoptionwindow_t *window, TC *str, W len)
{
	W err;

	err = cins_txt(window->filter.id, (PNT){0x8000, 0x8000}, str);
	if (err < 0) {
		return err;
	}

	err = cget_val(window->filter.id, 1000, (W*)(window->filter.buf+7));
	if (err < 0) {
		return err;
	}
	window->filter.buf_written = err;

	return err;
}

LOCAL VOID subjectoptionwindow_actionfilter(subjectoptionwindow_t *window, WEVENT *wev, bchanlhmievent_t *evt)
{
	W i, len;

	i = cact_par(window->filter.id, wev);
	if (i & 0x2000) {
		window->filter.nextaction = True;
		switch (i) {
		case	P_MENU:
			if ((wev->s.type == EV_KEYDWN)&&(wev->s.stat & ES_CMD)) {
				evt->type = BCHANLHMIEVENT_TYPE_SUBJECTOPTIONWINDOW_PARTS_FILTER_KEYMENU;
				evt->data.subjectoptionwindow_filter_keymenu.keycode = wev->e.data.key.code;
			} else {
				evt->type = BCHANLHMIEVENT_TYPE_SUBJECTOPTIONWINDOW_PARTS_FILTER_MENU;
				evt->data.subjectoptionwindow_filter_menu.pos = wev->s.pos;
			}
			subjectoptionwindow_setflag(window, SUBJECTOPTIONWINDOW_FLAG_PARTS_NEXTACTION);
			break;
		default:
			wugt_evt(wev);
			subjectoptionwindow_setflag(window, SUBJECTOPTIONWINDOW_FLAG_PARTS_OTHEREVENT);
			break;
		}
		return;
	}
	window->filter.nextaction = False;
	if (i & 0x1000) {
		len = cget_val(window->filter.id, 1000, (W*)(window->filter.buf+7));
		if (len > 0) {
			window->filter.buf_written = len;
		}
	}
	switch (i & 7) {
	case	P_BUT:
		cchg_par(window->filter.id, P_INACT);
		cchg_par(window->filter.id, P_ACT);
		wugt_evt(wev);
		break;
	case	P_TAB:
		break;
	case	P_NL:
	case	P_END:
		evt->type = BCHANLHMIEVENT_TYPE_SUBJECTOPTIONWINDOW_PARTS_FILTER_DETERMINE;
		evt->data.subjectoptionwindow_filter_determine.value = window->filter.buf+7;
		evt->data.subjectoptionwindow_filter_determine.len = window->filter.buf_written;
		break;
	case	P_MOVE:
		evt->type = BCHANLHMIEVENT_TYPE_SUBJECTOPTIONWINDOW_PARTS_FILTER_MOVE;
		evt->data.subjectoptionwindow_filter_move.rel_wid = wev->s.wid;
		evt->data.subjectoptionwindow_filter_move.pos = wev->s.pos;
		break;
	case	P_COPY:
		evt->type = BCHANLHMIEVENT_TYPE_SUBJECTOPTIONWINDOW_PARTS_FILTER_COPY;
		evt->data.subjectoptionwindow_filter_copy.rel_wid = wev->s.wid;
		evt->data.subjectoptionwindow_filter_copy.pos = wev->s.pos;
		break;
	}
}

EXPORT W subjectoptionwindow_setordervalue(subjectoptionwindow_t *window, SUBJECTOPTIONWINDOW_ORDERVALUE_T value)
{
	W val;

	val = window->order.value = value;
	if (window->wid < 0) {
		return 0;
	}

	return cset_val(window->order.id, 1, (W*)(&val));
}

EXPORT W subjectoptionwindow_getordervalue(subjectoptionwindow_t *window, SUBJECTOPTIONWINDOW_ORDERVALUE_T *value)
{
	W val,err;

	if (window->wid > 0) {
		err = cget_val(window->order.id, 1, (W*)(&val));
		if (err < 0) {
			return err;
		}
	}
	*value = window->order.value = val;

	return 0;
}

LOCAL VOID subjectoptionwindow_actionorder(subjectoptionwindow_t *window, WEVENT *wev, bchanlhmievent_t *evt)
{
	W i;

	i = cact_par(window->order.id, wev);
	if ((i & 0x5000) != 0x5000) {
		return;
	}
	window->order.value = i & 0xfff;
	evt->type = BCHANLHMIEVENT_TYPE_SUBJECTOPTIONWINDOW_PARTS_ORDER_CHANGE;
	evt->data.subjectoptionwindow_order_change.value = window->order.value;
}

EXPORT W subjectoptionwindow_setorderbyvalue(subjectoptionwindow_t *window, SUBJECTOPTIONWINDOW_ORDERBYVALUE_T value)
{
	W val;

	val = window->orderby.value = value;
	if (window->wid < 0) {
		return 0;
	}

	return cset_val(window->orderby.id, 1, (W*)(&val));
}

EXPORT W subjectoptionwindow_getorderbyvalue(subjectoptionwindow_t *window, SUBJECTOPTIONWINDOW_ORDERBYVALUE_T *value)
{
	W val,err;

	if (window->wid > 0) {
		err = cget_val(window->orderby.id, 1, (W*)(&val));
		if (err < 0) {
			return err;
		}
	}
	*value = window->orderby.value = val;

	return 0;
}

LOCAL VOID subjectoptionwindow_actionorderby(subjectoptionwindow_t *window, WEVENT *wev, bchanlhmievent_t *evt)
{
	W i;

	i = cact_par(window->orderby.id, wev);
	if ((i & 0x5000) != 0x5000) {
		return;
	}
	window->orderby.value = i & 0xfff;
	evt->type = BCHANLHMIEVENT_TYPE_SUBJECTOPTIONWINDOW_PARTS_ORDERBY_CHANGE;
	evt->data.subjectoptionwindow_orderby_change.value = window->orderby.value;
}

EXPORT Bool subjectoptionwindow_isopen(subjectoptionwindow_t *window)
{
	if (window->wid < 0) {
		return False;
	}
	return True;
}

LOCAL VOID subjectoptionwindow_draw(subjectoptionwindow_t *window, RECT *r)
{
	cdsp_pwd(window->wid, r, P_RDISP);
	gdra_stp(window->gid, 8, 26, (TC[]){0x2555, 0x2523, 0x256b, 0x253f, 0x2127, TNULL}, 5, G_STORE);
	gdra_stp(window->gid, 8, 58, (TC[]){0x4a42, 0x2459, 0x3d67, 0x2127, TNULL}, 4, G_STORE);
}

LOCAL VOID subjectoptionwindow_redisp(subjectoptionwindow_t *window)
{
	RECT r;
	do {
		if (wsta_dsp(window->wid, &r, NULL) == 0) {
			break;
		}
		wera_wnd(window->wid, &r);
		subjectoptionwindow_draw(window, &r);
	} while (wend_dsp(window->wid) > 0);
}

EXPORT W subjectoptionwindow_requestredisp(subjectoptionwindow_t *window)
{
	return wreq_dsp(window->wid);
}

EXPORT GID subjectoptionwindow_getGID(subjectoptionwindow_t *window)
{
	return wget_gid(window->wid);
}

EXPORT WID subjectoptionwindow_getWID(subjectoptionwindow_t *window)
{
	return window->wid;
}

EXPORT W subjectoptionwindow_settitle(subjectoptionwindow_t *window, TC *title)
{
	tc_strncpy(window->title, title, 256);
	window->title[256] = TNULL;
	return wset_tit(window->wid, -1, window->title, 0);
}

EXPORT Bool subjectoptionwindow_isactive(subjectoptionwindow_t *window)
{
	WID wid;
	wid = wget_act(NULL);
	if (window->wid == wid) {
		return True;
	}
	return False;
}

LOCAL VOID subjectoptionwindow_butdnwork(subjectoptionwindow_t *window, WEVENT *wev, bchanlhmievent_t *evt)
{
	PAID id;
	W ret;

	ret = cfnd_par(window->wid, wev->s.pos, &id);
	if (ret <= 0) {
		return;
	}
	if (id == window->filter.id) {
		memcpy(&window->savedwev, wev, sizeof(WEVENT));
		subjectoptionwindow_actionfilter(window, wev, evt);
		return;
	}
	if (id == window->order.id) {
		subjectoptionwindow_actionorder(window, wev, evt);
		return;
	}
	if (id == window->orderby.id) {
		subjectoptionwindow_actionorderby(window, wev, evt);
		return;
	}
}

EXPORT W subjectoptionwindow_open(subjectoptionwindow_t *window)
{
	WID wid;

	if (window->wid > 0) {
		return 0;
	}

	wid = wopn_wnd(WA_STD|WA_SUBW, window->parent->wid, &(window->r), NULL, 2, window->title, &window->bgpat, NULL);
	if (wid < 0) {
		DP_ER("wopn_wnd: subjectoption error", wid);
		return wid;
	}
	window->wid = wid;
	window->gid = wget_gid(wid);

	window->filter.id = copn_par(wid, window->filter.dnum, NULL);
	if (window->filter.id < 0) {
		DP_ER("ccre_xxx filter error:", window->filter.id);
	}
	cset_val(window->filter.id, 1000, (W*)(window->filter.buf+7));
	window->order.id = copn_par(wid, window->order.dnum, NULL);
	if (window->order.id < 0) {
		DP_ER("ccre_xxx order error:", window->order.id);
	}
	cset_val(window->order.id, 1, (W*)(&window->order.value));
	window->orderby.id = copn_par(wid, window->orderby.dnum, NULL);
	if (window->orderby.id < 0) {
		DP_ER("ccre_xxx orderby error:", window->orderby.id);
	}
	cset_val(window->orderby.id, 1, (W*)(&window->orderby.value));

	wreq_dsp(wid);

	return 0;
}

EXPORT VOID subjectoptionwindow_close(subjectoptionwindow_t *window)
{
	WDSTAT stat;
	W err;

	if (window->wid < 0) {
		return;
	}

	stat.attr = WA_STD;
	err = wget_sts(window->wid, &stat, NULL);
	if (err >= 0) {
		window->r = stat.r;
	}
	err = cget_val(window->orderby.id, 1, (W*)(&window->orderby.value));
	err = cget_val(window->order.id, 1, (W*)(&window->order.value));
	err = cget_val(window->filter.id, 1000, (W*)(window->filter.buf+7));
	if (err >= 0) {
		window->filter.buf_written = err;
	}
	cdel_pwd(window->wid, NOCLR);
	wcls_wnd(window->wid, CLR);
	window->wid = -1;
	window->gid = -1;
}

#define REGISTEREXTERNALWINDOW_FLAG_DRAWREQUEST 0x00000001
#define REGISTEREXTERNALWINDOW_FLAG_PARTS_OTHEREVENT 0x0000000f
#define REGISTEREXTERNALWINDOW_FLAG_PARTS_NEXTACTION 0x00000010

#define registerexternalwindow_setflag(window, flagx) (window)->flag = (window)->flag | (flagx)
#define registerexternalwindow_clearflag(window, flagx) (window)->flag = (window)->flag & ~(flagx)
#define registerexternalwindow_issetflag(window, flagx) (((window)->flag & (flagx)) == 0 ? False : True)

EXPORT W registerexternalwindow_setboradnametext(registerexternalwindow_t *window, TC *str, W len)
{
	W cp_len;

	if (len < 1000) {
		cp_len = len;
	} else {
		cp_len = 1000;
	}
	memcpy(window->boradname.buf+7, str, cp_len * sizeof(TC));
	window->boradname.buf[7 + cp_len] = TNULL;
	window->boradname.buf_written = cp_len;
	if (window->wid < 0) {
		return 0;
	}

	return cset_val(window->boradname.id, cp_len, (W*)(window->boradname.buf+7));
}

EXPORT W registerexternalwindow_getboradnametext(registerexternalwindow_t *window, TC *str, W len)
{
	W err, cp_len;

	if (window->wid > 0) {
		err = cget_val(window->boradname.id, 1000, (W*)(window->boradname.buf+7));
		if (err < 0) {
			return err;
		}
		window->boradname.buf_written = err;
	}

	if (len < window->boradname.buf_written) {
		cp_len = len;
	} else {
		cp_len = window->boradname.buf_written;
	}
	memcpy(str, window->boradname.buf + 7, cp_len * sizeof(TC));

	return cp_len;
}

EXPORT W registerexternalwindow_cutboradnametext(registerexternalwindow_t *window, TC *str, W len, Bool cut)
{
	W err, len0;

	len0 = ccut_txt(window->boradname.id, len, str, cut == False ? 0 : 1);
	if (len0 < 0) {
		return len0;
	}

	if (cut != False) {
		err = cget_val(window->boradname.id, 1000, (W*)(window->boradname.buf+7));
		if (err < 0) {
			return err;
		}
		window->boradname.buf_written = err;
		return len0;
	}

	return len0;
}

EXPORT W registerexternalwindow_insertboradnametext(registerexternalwindow_t *window, TC *str, W len)
{
	W err;

	err = cins_txt(window->boradname.id, (PNT){0x8000, 0x8000}, str);
	if (err < 0) {
		return err;
	}

	err = cget_val(window->boradname.id, 1000, (W*)(window->boradname.buf+7));
	if (err < 0) {
		return err;
	}
	window->boradname.buf_written = err;

	return err;
}

LOCAL VOID registerexternalwindow_actionboradname(registerexternalwindow_t *window, WEVENT *wev, bchanlhmievent_t *evt)
{
	W i, len;

	i = cact_par(window->boradname.id, wev);
	if (i & 0x2000) {
		window->boradname.nextaction = True;
		switch (i) {
		case	P_MENU:
			if ((wev->s.type == EV_KEYDWN)&&(wev->s.stat & ES_CMD)) {
				evt->type = BCHANLHMIEVENT_TYPE_REGISTEREXTERNALWINDOW_PARTS_BORADNAME_KEYMENU;
				evt->data.registerexternalwindow_boradname_keymenu.keycode = wev->e.data.key.code;
			} else {
				evt->type = BCHANLHMIEVENT_TYPE_REGISTEREXTERNALWINDOW_PARTS_BORADNAME_MENU;
				evt->data.registerexternalwindow_boradname_menu.pos = wev->s.pos;
			}
			registerexternalwindow_setflag(window, REGISTEREXTERNALWINDOW_FLAG_PARTS_NEXTACTION);
			break;
		default:
			wugt_evt(wev);
			registerexternalwindow_setflag(window, REGISTEREXTERNALWINDOW_FLAG_PARTS_OTHEREVENT);
			break;
		}
		return;
	}
	window->boradname.nextaction = False;
	if (i & 0x1000) {
		len = cget_val(window->boradname.id, 1000, (W*)(window->boradname.buf+7));
		if (len > 0) {
			window->boradname.buf_written = len;
		}
	}
	switch (i & 7) {
	case	P_BUT:
		cchg_par(window->boradname.id, P_INACT);
		cchg_par(window->boradname.id, P_ACT);
		wugt_evt(wev);
		break;
	case	P_TAB:
		break;
	case	P_NL:
	case	P_END:
		evt->type = BCHANLHMIEVENT_TYPE_REGISTEREXTERNALWINDOW_PARTS_BORADNAME_DETERMINE;
		evt->data.registerexternalwindow_boradname_determine.value = window->boradname.buf+7;
		evt->data.registerexternalwindow_boradname_determine.len = window->boradname.buf_written;
		break;
	case	P_MOVE:
		evt->type = BCHANLHMIEVENT_TYPE_REGISTEREXTERNALWINDOW_PARTS_BORADNAME_MOVE;
		evt->data.registerexternalwindow_boradname_move.rel_wid = wev->s.wid;
		evt->data.registerexternalwindow_boradname_move.pos = wev->s.pos;
		break;
	case	P_COPY:
		evt->type = BCHANLHMIEVENT_TYPE_REGISTEREXTERNALWINDOW_PARTS_BORADNAME_COPY;
		evt->data.registerexternalwindow_boradname_copy.rel_wid = wev->s.wid;
		evt->data.registerexternalwindow_boradname_copy.pos = wev->s.pos;
		break;
	}
}

EXPORT W registerexternalwindow_seturltext(registerexternalwindow_t *window, TC *str, W len)
{
	W cp_len;

	if (len < 1000) {
		cp_len = len;
	} else {
		cp_len = 1000;
	}
	memcpy(window->url.buf+7, str, cp_len * sizeof(TC));
	window->url.buf[7 + cp_len] = TNULL;
	window->url.buf_written = cp_len;
	if (window->wid < 0) {
		return 0;
	}

	return cset_val(window->url.id, cp_len, (W*)(window->url.buf+7));
}

EXPORT W registerexternalwindow_geturltext(registerexternalwindow_t *window, TC *str, W len)
{
	W err, cp_len;

	if (window->wid > 0) {
		err = cget_val(window->url.id, 1000, (W*)(window->url.buf+7));
		if (err < 0) {
			return err;
		}
		window->url.buf_written = err;
	}

	if (len < window->url.buf_written) {
		cp_len = len;
	} else {
		cp_len = window->url.buf_written;
	}
	memcpy(str, window->url.buf + 7, cp_len * sizeof(TC));

	return cp_len;
}

EXPORT W registerexternalwindow_cuturltext(registerexternalwindow_t *window, TC *str, W len, Bool cut)
{
	W err, len0;

	len0 = ccut_txt(window->url.id, len, str, cut == False ? 0 : 1);
	if (len0 < 0) {
		return len0;
	}

	if (cut != False) {
		err = cget_val(window->url.id, 1000, (W*)(window->url.buf+7));
		if (err < 0) {
			return err;
		}
		window->url.buf_written = err;
		return len0;
	}

	return len0;
}

EXPORT W registerexternalwindow_inserturltext(registerexternalwindow_t *window, TC *str, W len)
{
	W err;

	err = cins_txt(window->url.id, (PNT){0x8000, 0x8000}, str);
	if (err < 0) {
		return err;
	}

	err = cget_val(window->url.id, 1000, (W*)(window->url.buf+7));
	if (err < 0) {
		return err;
	}
	window->url.buf_written = err;

	return err;
}

LOCAL VOID registerexternalwindow_actionurl(registerexternalwindow_t *window, WEVENT *wev, bchanlhmievent_t *evt)
{
	W i, len;

	i = cact_par(window->url.id, wev);
	if (i & 0x2000) {
		window->url.nextaction = True;
		switch (i) {
		case	P_MENU:
			if ((wev->s.type == EV_KEYDWN)&&(wev->s.stat & ES_CMD)) {
				evt->type = BCHANLHMIEVENT_TYPE_REGISTEREXTERNALWINDOW_PARTS_URL_KEYMENU;
				evt->data.registerexternalwindow_url_keymenu.keycode = wev->e.data.key.code;
			} else {
				evt->type = BCHANLHMIEVENT_TYPE_REGISTEREXTERNALWINDOW_PARTS_URL_MENU;
				evt->data.registerexternalwindow_url_menu.pos = wev->s.pos;
			}
			registerexternalwindow_setflag(window, REGISTEREXTERNALWINDOW_FLAG_PARTS_NEXTACTION);
			break;
		default:
			wugt_evt(wev);
			registerexternalwindow_setflag(window, REGISTEREXTERNALWINDOW_FLAG_PARTS_OTHEREVENT);
			break;
		}
		return;
	}
	window->url.nextaction = False;
	if (i & 0x1000) {
		len = cget_val(window->url.id, 1000, (W*)(window->url.buf+7));
		if (len > 0) {
			window->url.buf_written = len;
		}
	}
	switch (i & 7) {
	case	P_BUT:
		cchg_par(window->url.id, P_INACT);
		cchg_par(window->url.id, P_ACT);
		wugt_evt(wev);
		break;
	case	P_TAB:
		break;
	case	P_NL:
	case	P_END:
		evt->type = BCHANLHMIEVENT_TYPE_REGISTEREXTERNALWINDOW_PARTS_URL_DETERMINE;
		evt->data.registerexternalwindow_url_determine.value = window->url.buf+7;
		evt->data.registerexternalwindow_url_determine.len = window->url.buf_written;
		break;
	case	P_MOVE:
		evt->type = BCHANLHMIEVENT_TYPE_REGISTEREXTERNALWINDOW_PARTS_URL_MOVE;
		evt->data.registerexternalwindow_url_move.rel_wid = wev->s.wid;
		evt->data.registerexternalwindow_url_move.pos = wev->s.pos;
		break;
	case	P_COPY:
		evt->type = BCHANLHMIEVENT_TYPE_REGISTEREXTERNALWINDOW_PARTS_URL_COPY;
		evt->data.registerexternalwindow_url_copy.rel_wid = wev->s.wid;
		evt->data.registerexternalwindow_url_copy.pos = wev->s.pos;
		break;
	}
}

EXPORT Bool registerexternalwindow_isopen(registerexternalwindow_t *window)
{
	if (window->wid < 0) {
		return False;
	}
	return True;
}

LOCAL VOID registerexternalwindow_draw(registerexternalwindow_t *window, RECT *r)
{
	cdsp_pwd(window->wid, r, P_RDISP);
	gdra_stp(window->gid, 8, 26, (TC[]){0x4844, 0x4c3e, 0x2127, TNULL}, 3, G_STORE);
	gdra_stp(window->gid, 8, 58, (TC[]){0x2355, 0x2352, 0x234c, 0x2127, TNULL}, 4, G_STORE);
}

LOCAL VOID registerexternalwindow_redisp(registerexternalwindow_t *window)
{
	RECT r;
	do {
		if (wsta_dsp(window->wid, &r, NULL) == 0) {
			break;
		}
		wera_wnd(window->wid, &r);
		registerexternalwindow_draw(window, &r);
	} while (wend_dsp(window->wid) > 0);
}

EXPORT W registerexternalwindow_requestredisp(registerexternalwindow_t *window)
{
	return wreq_dsp(window->wid);
}

EXPORT GID registerexternalwindow_getGID(registerexternalwindow_t *window)
{
	return wget_gid(window->wid);
}

EXPORT WID registerexternalwindow_getWID(registerexternalwindow_t *window)
{
	return window->wid;
}

EXPORT W registerexternalwindow_settitle(registerexternalwindow_t *window, TC *title)
{
	tc_strncpy(window->title, title, 256);
	window->title[256] = TNULL;
	return wset_tit(window->wid, -1, window->title, 0);
}

EXPORT Bool registerexternalwindow_isactive(registerexternalwindow_t *window)
{
	WID wid;
	wid = wget_act(NULL);
	if (window->wid == wid) {
		return True;
	}
	return False;
}

LOCAL VOID registerexternalwindow_butdnwork(registerexternalwindow_t *window, WEVENT *wev, bchanlhmievent_t *evt)
{
	PAID id;
	W ret;

	ret = cfnd_par(window->wid, wev->s.pos, &id);
	if (ret <= 0) {
		return;
	}
	if (id == window->boradname.id) {
		memcpy(&window->savedwev, wev, sizeof(WEVENT));
		registerexternalwindow_actionboradname(window, wev, evt);
		return;
	}
	if (id == window->url.id) {
		memcpy(&window->savedwev, wev, sizeof(WEVENT));
		registerexternalwindow_actionurl(window, wev, evt);
		return;
	}
	if (id == window->determine.id) {
		ret = cact_par(window->determine.id, wev);
		if ((ret & 0x5000) != 0x5000) {
			return;
		}
		evt->type = BCHANLHMIEVENT_TYPE_REGISTEREXTERNALWINDOW_PARTS_DETERMINE_PUSH;
		return;
	}
	if (id == window->cancel.id) {
		ret = cact_par(window->cancel.id, wev);
		if ((ret & 0x5000) != 0x5000) {
			return;
		}
		evt->type = BCHANLHMIEVENT_TYPE_REGISTEREXTERNALWINDOW_PARTS_CANCEL_PUSH;
		return;
	}
}

EXPORT W registerexternalwindow_open(registerexternalwindow_t *window)
{
	WID wid;
	RECT r;

	if (window->wid > 0) {
		return 0;
	}

	wid = wopn_wnd(WA_STD, window->parent, &(window->r), NULL, 2, window->title, &window->bgpat, NULL);
	if (wid < 0) {
		DP_ER("wopn_wnd: subjectoption error", wid);
		return wid;
	}
	window->wid = wid;
	window->gid = wget_gid(wid);

	r = (RECT){{80, 8, 368, 34}};
	window->boradname.id = ccre_tbx(wid, TB_PARTS|P_DISP, &r, 1000, window->boradname.buf, NULL);
	if (window->boradname.id < 0) {
		DP_ER("ccre_xxx boradname error:", window->boradname.id);
	}
	r = (RECT){{80, 38, 368, 64}};
	window->url.id = ccre_tbx(wid, TB_PARTS|P_DISP, &r, 1000, window->url.buf, NULL);
	if (window->url.id < 0) {
		DP_ER("ccre_xxx url error:", window->url.id);
	}
	r = (RECT){{226, 72, 368, 98}};
	window->determine.id = ccre_msw(wid, MS_PARTS|P_DISP, &r, (TC[]){MC_STR, 0x4449, 0x3243, TNULL}, NULL);
	if (window->determine.id < 0) {
		DP_ER("ccre_xxx determine error:", window->determine.id);
	}
	r = (RECT){{8, 72, 150, 98}};
	window->cancel.id = ccre_msw(wid, MS_PARTS|P_DISP, &r, (TC[]){MC_STR, 0x3c68, 0x246a, 0x3e43, 0x2437, TNULL}, NULL);
	if (window->cancel.id < 0) {
		DP_ER("ccre_xxx cancel error:", window->cancel.id);
	}

	wreq_dsp(wid);

	return 0;
}

EXPORT VOID registerexternalwindow_close(registerexternalwindow_t *window)
{
	WDSTAT stat;
	W err;

	if (window->wid < 0) {
		return;
	}

	stat.attr = WA_STD;
	err = wget_sts(window->wid, &stat, NULL);
	if (err >= 0) {
		window->r = stat.r;
	}
	err = cget_val(window->url.id, 1000, (W*)(window->url.buf+7));
	if (err >= 0) {
		window->url.buf_written = err;
	}
	err = cget_val(window->boradname.id, 1000, (W*)(window->boradname.buf+7));
	if (err >= 0) {
		window->boradname.buf_written = err;
	}
	cdel_pwd(window->wid, NOCLR);
	wcls_wnd(window->wid, CLR);
	window->wid = -1;
	window->gid = -1;
}

#define EXTERNALBBSWINDOW_FLAG_DRAWREQUEST 0x00000001
#define EXTERNALBBSWINDOW_FLAG_RSCROLLING 0x00000002
#define EXTERNALBBSWINDOW_FLAG_BSCROLLING 0x00000004

#define externalbbswindow_setflag(window, flagx) (window)->flag = (window)->flag | (flagx)
#define externalbbswindow_clearflag(window, flagx) (window)->flag = (window)->flag & ~(flagx)
#define externalbbswindow_issetflag(window, flagx) (((window)->flag & (flagx)) == 0 ? False : True)

EXPORT VOID externalbbswindow_scrollbyvalue(externalbbswindow_t *window, W dh, W dv)
{
	hmi_windowscroll_scrollworkrect(&window->wscr, dh, dv);
}

EXPORT W externalbbswindow_setdrawrect(externalbbswindow_t *window, W l, W t, W r, W b)
{
	return hmi_windowscroll_setdrawrect(&window->wscr, l, t, r, b);
}

EXPORT W externalbbswindow_setworkrect(externalbbswindow_t *window, W l, W t, W r, W b)
{
	return hmi_windowscroll_setworkrect(&window->wscr, l, t, r, b);
}

EXPORT W externalbbswindow_scrollworkarea(externalbbswindow_t *window, W dh, W dv)
{
	W err;
	err = wscr_wnd(window->wid, NULL, dh, dv, W_MOVE|W_RDSET);
	if (err < 0) {
		return err;
	}
	if ((err & W_RDSET) != 0) {
		externalbbswindow_setflag(window, EXTERNALBBSWINDOW_FLAG_DRAWREQUEST);
	}
	return 0;
}

EXPORT W externalbbswindow_getworkrect(externalbbswindow_t *window, RECT *r)
{
	return wget_wrk(window->wid, r);
}

EXPORT Bool externalbbswindow_isopen(externalbbswindow_t *window)
{
	if (window->wid < 0) {
		return False;
	}
	return True;
}

EXPORT VOID externalbbswindow_responsepasterequest(externalbbswindow_t *window, W nak, PNT *pos)
{
	if (pos != NULL) {
		window->savedwev.r.r.p.rightbot.x = pos->x;
		window->savedwev.r.r.p.rightbot.y = pos->y;
	}
	wrsp_evt(&window->savedwev, nak);
}

EXPORT W externalbbswindow_startredisp(externalbbswindow_t *window, RECT *r)
{
	return wsta_dsp(window->wid, r, NULL);
}

EXPORT W externalbbswindow_endredisp(externalbbswindow_t *window)
{
	return wend_dsp(window->wid);
}

EXPORT W externalbbswindow_eraseworkarea(externalbbswindow_t *window, RECT *r)
{
	return wera_wnd(window->wid, r);
}

EXPORT W externalbbswindow_requestredisp(externalbbswindow_t *window)
{
	return wreq_dsp(window->wid);
}

EXPORT GID externalbbswindow_startdrag(externalbbswindow_t *window)
{
	return wsta_drg(window->wid, 0);
}

EXPORT W externalbbswindow_getdrag(externalbbswindow_t *window, PNT *pos, WID *wid, PNT *pos_butup)
{
	W etype;

	etype = wget_drg(pos, &window->savedwev);
	*wid = window->savedwev.s.wid;
	if (etype == EV_BUTUP) {
		*pos_butup = window->savedwev.s.pos;
	}

	return etype;
}

EXPORT VOID externalbbswindow_enddrag(externalbbswindow_t *window)
{
	wend_drg();
}

EXPORT GID externalbbswindow_getGID(externalbbswindow_t *window)
{
	return wget_gid(window->wid);
}

EXPORT WID externalbbswindow_getWID(externalbbswindow_t *window)
{
	return window->wid;
}

EXPORT W externalbbswindow_settitle(externalbbswindow_t *window, TC *title)
{
	tc_strncpy(window->title, title, 256);
	window->title[256] = TNULL;
	return wset_tit(window->wid, -1, window->title, 0);
}

EXPORT Bool externalbbswindow_isactive(externalbbswindow_t *window)
{
	WID wid;
	wid = wget_act(NULL);
	if (window->wid == wid) {
		return True;
	}
	return False;
}

LOCAL VOID externalbbswindow_butdnwork(externalbbswindow_t *window, WEVENT *wev, bchanlhmievent_t *evt)
{
	evt->type = BCHANLHMIEVENT_TYPE_EXTERNALBBSWINDOW_BUTDN;
	evt->data.externalbbswindow_butdn.type = wchk_dck(wev->s.time);
	evt->data.externalbbswindow_butdn.pos = wev->s.pos;
	memcpy(&window->savedwev, wev, sizeof(WEVENT));
}

LOCAL VOID externalbbswindow_resize(externalbbswindow_t *window, SIZE *sz)
{
	RECT work;
	Bool workchange = False;

	wget_wrk(window->wid, &work);
	if (work.c.left != 0) {
		work.c.left = 0;
		workchange = True;
	}
	if (work.c.top != 0) {
		work.c.top = 0;
		workchange = True;
	}
	wset_wrk(window->wid, &work);
	gset_vis(window->gid, work);

	if (workchange == True) {
		wera_wnd(window->wid, NULL);
		wreq_dsp(window->wid);
	}

	sz->v = work.c.bottom - work.c.top;
	sz->h = work.c.right - work.c.left;
}

EXPORT W externalbbswindow_open(externalbbswindow_t *window)
{
	WID wid;

	if (window->wid > 0) {
		return 0;
	}

	wid = wopn_wnd(WA_STD|WA_SIZE|WA_HHDL|WA_VHDL|WA_BBAR|WA_RBAR, window->parent, &(window->r), NULL, 2, window->title, &window->bgpat, NULL);
	if (wid < 0) {
		DP_ER("wopn_wnd: subjectoption error", wid);
		return wid;
	}
	window->wid = wid;
	window->gid = wget_gid(wid);
	hmi_windowscroll_settarget(&window->wscr, wid);


	wreq_dsp(wid);

	return 0;
}

EXPORT VOID externalbbswindow_close(externalbbswindow_t *window)
{
	WDSTAT stat;
	W err;

	if (window->wid < 0) {
		return;
	}

	stat.attr = WA_STD;
	err = wget_sts(window->wid, &stat, NULL);
	if (err >= 0) {
		window->r = stat.r;
	}
	wcls_wnd(window->wid, CLR);
	window->wid = -1;
	window->gid = -1;
}

LOCAL VOID bchanlhmi_setswitchbutdnflag(bchanlhmi_t *hmi)
{
	hmi->flag = hmi->flag | BCHANLHMI_FLAG_SWITCHBUTDN;
}

LOCAL VOID bchanlhmi_clearswitchbutdnflag(bchanlhmi_t *hmi)
{
	hmi->flag = hmi->flag & ~BCHANLHMI_FLAG_SWITCHBUTDN;
}

LOCAL Bool bchanlhmi_issetswitchbutdnflag(bchanlhmi_t *hmi)
{
	if ((hmi->flag & BCHANLHMI_FLAG_SWITCHBUTDN) == 0) {
		return False;
	}
	return True;
}

LOCAL Bool bchanlhmi_issubjectwindowWID(bchanlhmi_t *hmi, WID wid)
{
	if (hmi->subjectwindow->wid == wid) {
		return True;
	}
	return False;
}

LOCAL Bool bchanlhmi_isbbsmenuwindowWID(bchanlhmi_t *hmi, WID wid)
{
	if (hmi->bbsmenuwindow->wid == wid) {
		return True;
	}
	return False;
}

LOCAL Bool bchanlhmi_issubjectoptionwindowWID(bchanlhmi_t *hmi, WID wid)
{
	if (hmi->subjectoptionwindow->wid == wid) {
		return True;
	}
	return False;
}

LOCAL Bool bchanlhmi_isregisterexternalwindowWID(bchanlhmi_t *hmi, WID wid)
{
	if (hmi->registerexternalwindow->wid == wid) {
		return True;
	}
	return False;
}

LOCAL Bool bchanlhmi_isexternalbbswindowWID(bchanlhmi_t *hmi, WID wid)
{
	if (hmi->externalbbswindow->wid == wid) {
		return True;
	}
	return False;
}

LOCAL VOID bchanlhmi_weventnull(bchanlhmi_t *hmi, WEVENT *wev, bchanlhmievent_t *evt)
{
	cidl_par(wev->s.wid, &wev->s.pos);
	if (wev->s.cmd != W_WORK)
		return;		/*作業領域外*/
	if (wev->s.stat & ES_CMD)
		return;	/*命令キーが押されている*/
	if (bchanlhmi_issubjectwindowWID(hmi, wev->s.wid) == True) {
		hmi->evt.type = BCHANLHMIEVENT_TYPE_SUBJECTWINDOW_MOUSEMOVE;
		hmi->evt.data.subjectwindow_mousemove.pos = wev->s.pos;
		hmi->evt.data.subjectwindow_mousemove.stat = wev->s.stat;
		return;
	}
	if (bchanlhmi_isbbsmenuwindowWID(hmi, wev->s.wid) == True) {
		hmi->evt.type = BCHANLHMIEVENT_TYPE_BBSMENUWINDOW_MOUSEMOVE;
		hmi->evt.data.bbsmenuwindow_mousemove.pos = wev->s.pos;
		hmi->evt.data.bbsmenuwindow_mousemove.stat = wev->s.stat;
		return;
	}
	if (bchanlhmi_issubjectoptionwindowWID(hmi, wev->s.wid) == True) {
		cidl_par(wev->s.wid, &wev->s.pos);
		return;
	}
	if (bchanlhmi_isregisterexternalwindowWID(hmi, wev->s.wid) == True) {
		cidl_par(wev->s.wid, &wev->s.pos);
		return;
	}
	if (bchanlhmi_isexternalbbswindowWID(hmi, wev->s.wid) == True) {
		gset_ptr(PS_SELECT, NULL, -1, -1);
		return;
	}
	/*ウィンドウ外*/
	hmi->evt.type = BCHANLHMIEVENT_TYPE_COMMON_MOUSEMOVE;
	hmi->evt.data.common_mousemove.pos = wev->s.pos;
}

LOCAL VOID bchanlhmi_weventrequest(bchanlhmi_t *hmi, WEVENT *wev, bchanlhmievent_t *evt)
{
	switch (wev->g.cmd) {
	case	W_REDISP:	/*再表示要求*/
		if (bchanlhmi_issubjectwindowWID(hmi, wev->g.wid) == True) {
			evt->type = BCHANLHMIEVENT_TYPE_SUBJECTWINDOW_DRAW;
			break;
		}
		if (bchanlhmi_isbbsmenuwindowWID(hmi, wev->g.wid) == True) {
			evt->type = BCHANLHMIEVENT_TYPE_BBSMENUWINDOW_DRAW;
			break;
		}
		if (bchanlhmi_issubjectoptionwindowWID(hmi, wev->g.wid) == True) {
			subjectoptionwindow_redisp(hmi->subjectoptionwindow);
			break;
		}
		if (bchanlhmi_isregisterexternalwindowWID(hmi, wev->g.wid) == True) {
			registerexternalwindow_redisp(hmi->registerexternalwindow);
			break;
		}
		if (bchanlhmi_isexternalbbswindowWID(hmi, wev->g.wid) == True) {
			evt->type = BCHANLHMIEVENT_TYPE_EXTERNALBBSWINDOW_DRAW;
			break;
		}
		break;
	case	W_PASTE:	/*貼込み要求*/
		if (bchanlhmi_issubjectwindowWID(hmi, wev->g.wid) == True) {
			evt->type = BCHANLHMIEVENT_TYPE_SUBJECTWINDOW_PASTE;
			memcpy(&hmi->subjectwindow->savedwev, wev, sizeof(WEVENT));
			break;
		}
		if (bchanlhmi_isexternalbbswindowWID(hmi, wev->g.wid) == True) {
			evt->type = BCHANLHMIEVENT_TYPE_EXTERNALBBSWINDOW_PASTE;
			memcpy(&hmi->externalbbswindow->savedwev, wev, sizeof(WEVENT));
			break;
		}
		wrsp_evt(wev, 1); /*NACK*/
		break;
	case	W_DELETE:	/*保存終了*/
		wrsp_evt(wev, 0);	/*ACK*/
		if (bchanlhmi_issubjectwindowWID(hmi, wev->g.wid) == True) {
			evt->type = BCHANLHMIEVENT_TYPE_SUBJECTWINDOW_CLOSE;
			evt->data.subjectwindow_close.save = True;
			break;
		}
		if (bchanlhmi_isbbsmenuwindowWID(hmi, wev->g.wid) == True) {
			evt->type = BCHANLHMIEVENT_TYPE_BBSMENUWINDOW_CLOSE;
			evt->data.bbsmenuwindow_close.save = True;
			break;
		}
		if (bchanlhmi_issubjectoptionwindowWID(hmi, wev->g.wid) == True) {
			subjectoptionwindow_close(hmi->subjectoptionwindow);
			break;
		}
		if (bchanlhmi_isregisterexternalwindowWID(hmi, wev->g.wid) == True) {
			registerexternalwindow_close(hmi->registerexternalwindow);
			break;
		}
		if (bchanlhmi_isexternalbbswindowWID(hmi, wev->g.wid) == True) {
			evt->type = BCHANLHMIEVENT_TYPE_EXTERNALBBSWINDOW_CLOSE;
			evt->data.externalbbswindow_close.save = True;
			break;
		}
		break;
	case	W_FINISH:	/*廃棄終了*/
		wrsp_evt(wev, 0);	/*ACK*/
		if (bchanlhmi_issubjectwindowWID(hmi, wev->g.wid) == True) {
			evt->type = BCHANLHMIEVENT_TYPE_SUBJECTWINDOW_CLOSE;
			evt->data.subjectwindow_close.save = False;
			break;
		}
		if (bchanlhmi_isbbsmenuwindowWID(hmi, wev->g.wid) == True) {
			evt->type = BCHANLHMIEVENT_TYPE_BBSMENUWINDOW_CLOSE;
			evt->data.bbsmenuwindow_close.save = False;
			break;
		}
		if (bchanlhmi_issubjectoptionwindowWID(hmi, wev->g.wid) == True) {
			subjectoptionwindow_close(hmi->subjectoptionwindow);
			break;
		}
		if (bchanlhmi_isregisterexternalwindowWID(hmi, wev->g.wid) == True) {
			registerexternalwindow_close(hmi->registerexternalwindow);
			break;
		}
		if (bchanlhmi_isexternalbbswindowWID(hmi, wev->g.wid) == True) {
			evt->type = BCHANLHMIEVENT_TYPE_EXTERNALBBSWINDOW_CLOSE;
			evt->data.externalbbswindow_close.save = False;
			break;
		}
		break;
	}
}

LOCAL VOID bchanlhmi_weventbutdn(bchanlhmi_t *hmi, WEVENT *wev, bchanlhmievent_t *evt)
{
	W i, err;
	W dh, dv; /* TODO: add check for exist scrollable window */

	switch	(wev->s.cmd) {
	case	W_PICT:
		switch (wchk_dck(wev->s.time)) {
		case	W_DCLICK:
			if (bchanlhmi_issubjectwindowWID(hmi, wev->s.wid) == True) {
				evt->type = BCHANLHMIEVENT_TYPE_SUBJECTWINDOW_CLOSE;
				evt->data.subjectwindow_close.save = True; /* TODO: tmp value */
				return;
			}
			if (bchanlhmi_isbbsmenuwindowWID(hmi, wev->s.wid) == True) {
				evt->type = BCHANLHMIEVENT_TYPE_BBSMENUWINDOW_CLOSE;
				evt->data.bbsmenuwindow_close.save = True; /* TODO: tmp value */
				return;
			}
			if (bchanlhmi_issubjectoptionwindowWID(hmi, wev->s.wid) == True) {
				subjectoptionwindow_close(hmi->subjectoptionwindow);
				return;
			}
			if (bchanlhmi_isregisterexternalwindowWID(hmi, wev->s.wid) == True) {
				registerexternalwindow_close(hmi->registerexternalwindow);
				return;
			}
			if (bchanlhmi_isexternalbbswindowWID(hmi, wev->s.wid) == True) {
				evt->type = BCHANLHMIEVENT_TYPE_EXTERNALBBSWINDOW_CLOSE;
				evt->data.externalbbswindow_close.save = True; /* TODO: tmp value */
				return;
			}
			return;
		case	W_PRESS:
			break;
		default:
			return;
		}
	case	W_FRAM:
	case	W_TITL:
		if (wmov_drg(wev, NULL) > 0) {
			if (bchanlhmi_issubjectwindowWID(hmi, wev->s.wid) == True) {
				evt->type = BCHANLHMIEVENT_TYPE_SUBJECTWINDOW_DRAW;
				return;
			}
			if (bchanlhmi_isbbsmenuwindowWID(hmi, wev->s.wid) == True) {
				evt->type = BCHANLHMIEVENT_TYPE_BBSMENUWINDOW_DRAW;
				return;
			}
			if (bchanlhmi_issubjectoptionwindowWID(hmi, wev->s.wid) == True) {
				subjectoptionwindow_redisp(hmi->subjectoptionwindow);
				return;
			}
			if (bchanlhmi_isregisterexternalwindowWID(hmi, wev->s.wid) == True) {
				registerexternalwindow_redisp(hmi->registerexternalwindow);
				return;
			}
			if (bchanlhmi_isexternalbbswindowWID(hmi, wev->s.wid) == True) {
				evt->type = BCHANLHMIEVENT_TYPE_EXTERNALBBSWINDOW_DRAW;
				return;
			}
		}
		return;
	case	W_LTHD:
	case	W_RTHD:
	case	W_LBHD:
	case	W_RBHD:
		switch (wchk_dck(wev->s.time)) {
		case	W_DCLICK:
			i = wchg_wnd(wev->s.wid, NULL, W_MOVE);
			break;
		case	W_PRESS:
			i = wrsz_drg(wev, NULL, NULL);
			break;
		default:
			return;
		}

		if (bchanlhmi_issubjectwindowWID(hmi, wev->s.wid) == True) {
			evt->type = BCHANLHMIEVENT_TYPE_SUBJECTWINDOW_RESIZE;
			subjectwindow_resize(hmi->subjectwindow, &evt->data.subjectwindow_resize.work_sz);
			hmi_windowscroll_updatebar(&hmi->subjectwindow->wscr);
			if (i > 0) {
				subjectwindow_setflag(hmi->subjectwindow, SUBJECTWINDOW_FLAG_DRAWREQUEST);
			}
			return;
		}
		if (bchanlhmi_isbbsmenuwindowWID(hmi, wev->s.wid) == True) {
			evt->type = BCHANLHMIEVENT_TYPE_BBSMENUWINDOW_RESIZE;
			bbsmenuwindow_resize(hmi->bbsmenuwindow, &evt->data.bbsmenuwindow_resize.work_sz);
			hmi_windowscroll_updatebar(&hmi->bbsmenuwindow->wscr);
			if (i > 0) {
				bbsmenuwindow_setflag(hmi->bbsmenuwindow, BBSMENUWINDOW_FLAG_DRAWREQUEST);
			}
			return;
		}
		if (bchanlhmi_isexternalbbswindowWID(hmi, wev->s.wid) == True) {
			evt->type = BCHANLHMIEVENT_TYPE_EXTERNALBBSWINDOW_RESIZE;
			externalbbswindow_resize(hmi->externalbbswindow, &evt->data.externalbbswindow_resize.work_sz);
			hmi_windowscroll_updatebar(&hmi->externalbbswindow->wscr);
			if (i > 0) {
				externalbbswindow_setflag(hmi->externalbbswindow, EXTERNALBBSWINDOW_FLAG_DRAWREQUEST);
			}
			return;
		}
		return;
	case	W_RBAR:
		if (bchanlhmi_issubjectwindowWID(hmi, wev->s.wid) == True) {
			err = hmi_windowscroll_weventrbar(&hmi->subjectwindow->wscr, wev, &dh, &dv);
			if (err < 0) {
				return;
			}
			if (err == 0) {
				subjectwindow_clearflag(hmi->subjectwindow, SUBJECTWINDOW_FLAG_RSCROLLING);
			} else {
				subjectwindow_setflag(hmi->subjectwindow, SUBJECTWINDOW_FLAG_RSCROLLING);
			}
			evt->type = BCHANLHMIEVENT_TYPE_SUBJECTWINDOW_SCROLL;
			evt->data.subjectwindow_scroll.dh = dh;
			evt->data.subjectwindow_scroll.dv = dv;
			return;
		}
		if (bchanlhmi_isbbsmenuwindowWID(hmi, wev->s.wid) == True) {
			err = hmi_windowscroll_weventrbar(&hmi->bbsmenuwindow->wscr, wev, &dh, &dv);
			if (err < 0) {
				return;
			}
			if (err == 0) {
				bbsmenuwindow_clearflag(hmi->bbsmenuwindow, BBSMENUWINDOW_FLAG_RSCROLLING);
			} else {
				bbsmenuwindow_setflag(hmi->bbsmenuwindow, BBSMENUWINDOW_FLAG_RSCROLLING);
			}
			evt->type = BCHANLHMIEVENT_TYPE_BBSMENUWINDOW_SCROLL;
			evt->data.bbsmenuwindow_scroll.dh = dh;
			evt->data.bbsmenuwindow_scroll.dv = dv;
			return;
		}
		if (bchanlhmi_isexternalbbswindowWID(hmi, wev->s.wid) == True) {
			err = hmi_windowscroll_weventrbar(&hmi->externalbbswindow->wscr, wev, &dh, &dv);
			if (err < 0) {
				return;
			}
			if (err == 0) {
				externalbbswindow_clearflag(hmi->externalbbswindow, EXTERNALBBSWINDOW_FLAG_RSCROLLING);
			} else {
				externalbbswindow_setflag(hmi->externalbbswindow, EXTERNALBBSWINDOW_FLAG_RSCROLLING);
			}
			evt->type = BCHANLHMIEVENT_TYPE_EXTERNALBBSWINDOW_SCROLL;
			evt->data.externalbbswindow_scroll.dh = dh;
			evt->data.externalbbswindow_scroll.dv = dv;
			return;
		}
		return;
	case	W_BBAR:
		if (bchanlhmi_issubjectwindowWID(hmi, wev->s.wid) == True) {
			err = hmi_windowscroll_weventbbar(&hmi->subjectwindow->wscr, wev, &dh, &dv);
			if (err < 0) {
				return;
			}
			if (err == 0) {
				subjectwindow_clearflag(hmi->subjectwindow, SUBJECTWINDOW_FLAG_BSCROLLING);
			} else {
				subjectwindow_setflag(hmi->subjectwindow, SUBJECTWINDOW_FLAG_BSCROLLING);
			}
			evt->type = BCHANLHMIEVENT_TYPE_SUBJECTWINDOW_SCROLL;
			evt->data.subjectwindow_scroll.dh = dh;
			evt->data.subjectwindow_scroll.dv = dv;
			return;
		}
		if (bchanlhmi_isbbsmenuwindowWID(hmi, wev->s.wid) == True) {
			err = hmi_windowscroll_weventbbar(&hmi->bbsmenuwindow->wscr, wev, &dh, &dv);
			if (err < 0) {
				return;
			}
			if (err == 0) {
				bbsmenuwindow_clearflag(hmi->bbsmenuwindow, BBSMENUWINDOW_FLAG_BSCROLLING);
			} else {
				bbsmenuwindow_setflag(hmi->bbsmenuwindow, BBSMENUWINDOW_FLAG_BSCROLLING);
			}
			evt->type = BCHANLHMIEVENT_TYPE_BBSMENUWINDOW_SCROLL;
			evt->data.bbsmenuwindow_scroll.dh = dh;
			evt->data.bbsmenuwindow_scroll.dv = dv;
			return;
		}
		if (bchanlhmi_isexternalbbswindowWID(hmi, wev->s.wid) == True) {
			err = hmi_windowscroll_weventbbar(&hmi->externalbbswindow->wscr, wev, &dh, &dv);
			if (err < 0) {
				return;
			}
			if (err == 0) {
				externalbbswindow_clearflag(hmi->externalbbswindow, EXTERNALBBSWINDOW_FLAG_BSCROLLING);
			} else {
				externalbbswindow_setflag(hmi->externalbbswindow, EXTERNALBBSWINDOW_FLAG_BSCROLLING);
			}
			evt->type = BCHANLHMIEVENT_TYPE_EXTERNALBBSWINDOW_SCROLL;
			evt->data.externalbbswindow_scroll.dh = dh;
			evt->data.externalbbswindow_scroll.dv = dv;
			return;
		}
		return;
	case	W_WORK:
		if (bchanlhmi_issubjectwindowWID(hmi, wev->s.wid) == True) {
			subjectwindow_butdnwork(hmi->subjectwindow, wev, evt);
			return;
		}
		if (bchanlhmi_isbbsmenuwindowWID(hmi, wev->s.wid) == True) {
			bbsmenuwindow_butdnwork(hmi->bbsmenuwindow, wev, evt);
			return;
		}
		if (bchanlhmi_issubjectoptionwindowWID(hmi, wev->s.wid) == True) {
			subjectoptionwindow_butdnwork(hmi->subjectoptionwindow, wev, evt);
			return;
		}
		if (bchanlhmi_isregisterexternalwindowWID(hmi, wev->s.wid) == True) {
			registerexternalwindow_butdnwork(hmi->registerexternalwindow, wev, evt);
			return;
		}
		if (bchanlhmi_isexternalbbswindowWID(hmi, wev->s.wid) == True) {
			externalbbswindow_butdnwork(hmi->externalbbswindow, wev, evt);
			return;
		}
		return;
	}

	return;
}

LOCAL VOID bchanlhmi_weventswitch(bchanlhmi_t *hmi, WEVENT *wev, bchanlhmievent_t *evt)
{
	bchanlhmi_setswitchbutdnflag(hmi);
}

LOCAL VOID bchanlhmi_weventreswitch(bchanlhmi_t *hmi, WEVENT *wev, bchanlhmievent_t *evt)
{
	bchanlhmi_setswitchbutdnflag(hmi);
	if (bchanlhmi_issubjectwindowWID(hmi, wev->s.wid) == True) {
		evt->type = BCHANLHMIEVENT_TYPE_SUBJECTWINDOW_DRAW;
	}
	if (bchanlhmi_isbbsmenuwindowWID(hmi, wev->s.wid) == True) {
		evt->type = BCHANLHMIEVENT_TYPE_BBSMENUWINDOW_DRAW;
	}
	if (bchanlhmi_issubjectoptionwindowWID(hmi, wev->s.wid) == True) {
		subjectoptionwindow_redisp(hmi->subjectoptionwindow);
		return;
	}
	if (bchanlhmi_isregisterexternalwindowWID(hmi, wev->s.wid) == True) {
		registerexternalwindow_redisp(hmi->registerexternalwindow);
		return;
	}
	if (bchanlhmi_isexternalbbswindowWID(hmi, wev->s.wid) == True) {
		evt->type = BCHANLHMIEVENT_TYPE_EXTERNALBBSWINDOW_DRAW;
	}
}

LOCAL VOID bchanlhmi_receivemessage(bchanlhmi_t *hmi, bchanlhmievent_t *evt)
{
	MESSAGE msg;
	W err;

	err = rcv_msg(MM_ALL, &msg, sizeof(MESSAGE), WAIT|NOCLR);
	if (err >= 0) {
		if (msg.msg_type == MS_TMOUT) { /* should be use other type? */
			evt->type = BCHANLHMIEVENT_TYPE_COMMON_TIMEOUT;
			evt->data.common_timeout.code = msg.msg_body.TMOUT.code;
		}
	}
	clr_msg(MM_ALL, MM_ALL);
}

LOCAL Bool bchanlhmi_checkflag(bchanlhmi_t *hmi, bchanlhmievent_t **evt)
{
	W err, dh, dv;

	if (subjectwindow_issetflag(hmi->subjectwindow, SUBJECTWINDOW_FLAG_RSCROLLING) == True) {
		err = hmi_windowscroll_weventrbar(&hmi->subjectwindow->wscr, &hmi->wev, &dh, &dv);
		if (err < 0) {
			subjectwindow_clearflag(hmi->subjectwindow, SUBJECTWINDOW_FLAG_RSCROLLING);
			return False;
		}
		if (err == 0) {
			subjectwindow_clearflag(hmi->subjectwindow, SUBJECTWINDOW_FLAG_RSCROLLING);
		} else {
			subjectwindow_setflag(hmi->subjectwindow, SUBJECTWINDOW_FLAG_RSCROLLING);
		}
		hmi->evt.type = BCHANLHMIEVENT_TYPE_SUBJECTWINDOW_SCROLL;
		hmi->evt.data.subjectwindow_scroll.dh = dh;
		hmi->evt.data.subjectwindow_scroll.dv = dv;
		return True;
	}
	if (subjectwindow_issetflag(hmi->subjectwindow, SUBJECTWINDOW_FLAG_BSCROLLING) == True) {
		err = hmi_windowscroll_weventbbar(&hmi->subjectwindow->wscr, &hmi->wev, &dh, &dv);
		if (err < 0) {
			subjectwindow_clearflag(hmi->subjectwindow, SUBJECTWINDOW_FLAG_BSCROLLING);
			return False;
		}
		if (err == 0) {
			subjectwindow_clearflag(hmi->subjectwindow, SUBJECTWINDOW_FLAG_BSCROLLING);
		} else {
			subjectwindow_setflag(hmi->subjectwindow, SUBJECTWINDOW_FLAG_BSCROLLING);
		}
		hmi->evt.type = BCHANLHMIEVENT_TYPE_SUBJECTWINDOW_SCROLL;
		hmi->evt.data.subjectwindow_scroll.dh = dh;
		hmi->evt.data.subjectwindow_scroll.dv = dv;
		return True;
	}
	if (bbsmenuwindow_issetflag(hmi->bbsmenuwindow, BBSMENUWINDOW_FLAG_RSCROLLING) == True) {
		err = hmi_windowscroll_weventrbar(&hmi->bbsmenuwindow->wscr, &hmi->wev, &dh, &dv);
		if (err < 0) {
			bbsmenuwindow_clearflag(hmi->bbsmenuwindow, BBSMENUWINDOW_FLAG_RSCROLLING);
			return False;
		}
		if (err == 0) {
			bbsmenuwindow_clearflag(hmi->bbsmenuwindow, BBSMENUWINDOW_FLAG_RSCROLLING);
		} else {
			bbsmenuwindow_setflag(hmi->bbsmenuwindow, BBSMENUWINDOW_FLAG_RSCROLLING);
		}
		hmi->evt.type = BCHANLHMIEVENT_TYPE_BBSMENUWINDOW_SCROLL;
		hmi->evt.data.bbsmenuwindow_scroll.dh = dh;
		hmi->evt.data.bbsmenuwindow_scroll.dv = dv;
		return True;
	}
	if (bbsmenuwindow_issetflag(hmi->bbsmenuwindow, BBSMENUWINDOW_FLAG_BSCROLLING) == True) {
		err = hmi_windowscroll_weventbbar(&hmi->bbsmenuwindow->wscr, &hmi->wev, &dh, &dv);
		if (err < 0) {
			bbsmenuwindow_clearflag(hmi->bbsmenuwindow, BBSMENUWINDOW_FLAG_BSCROLLING);
			return False;
		}
		if (err == 0) {
			bbsmenuwindow_clearflag(hmi->bbsmenuwindow, BBSMENUWINDOW_FLAG_BSCROLLING);
		} else {
			bbsmenuwindow_setflag(hmi->bbsmenuwindow, BBSMENUWINDOW_FLAG_BSCROLLING);
		}
		hmi->evt.type = BCHANLHMIEVENT_TYPE_BBSMENUWINDOW_SCROLL;
		hmi->evt.data.bbsmenuwindow_scroll.dh = dh;
		hmi->evt.data.bbsmenuwindow_scroll.dv = dv;
		return True;
	}
	if (externalbbswindow_issetflag(hmi->externalbbswindow, EXTERNALBBSWINDOW_FLAG_RSCROLLING) == True) {
		err = hmi_windowscroll_weventrbar(&hmi->externalbbswindow->wscr, &hmi->wev, &dh, &dv);
		if (err < 0) {
			externalbbswindow_clearflag(hmi->externalbbswindow, EXTERNALBBSWINDOW_FLAG_RSCROLLING);
			return False;
		}
		if (err == 0) {
			externalbbswindow_clearflag(hmi->externalbbswindow, EXTERNALBBSWINDOW_FLAG_RSCROLLING);
		} else {
			externalbbswindow_setflag(hmi->externalbbswindow, EXTERNALBBSWINDOW_FLAG_RSCROLLING);
		}
		hmi->evt.type = BCHANLHMIEVENT_TYPE_EXTERNALBBSWINDOW_SCROLL;
		hmi->evt.data.externalbbswindow_scroll.dh = dh;
		hmi->evt.data.externalbbswindow_scroll.dv = dv;
		return True;
	}
	if (externalbbswindow_issetflag(hmi->externalbbswindow, EXTERNALBBSWINDOW_FLAG_BSCROLLING) == True) {
		err = hmi_windowscroll_weventbbar(&hmi->externalbbswindow->wscr, &hmi->wev, &dh, &dv);
		if (err < 0) {
			externalbbswindow_clearflag(hmi->externalbbswindow, EXTERNALBBSWINDOW_FLAG_BSCROLLING);
			return False;
		}
		if (err == 0) {
			externalbbswindow_clearflag(hmi->externalbbswindow, EXTERNALBBSWINDOW_FLAG_BSCROLLING);
		} else {
			externalbbswindow_setflag(hmi->externalbbswindow, EXTERNALBBSWINDOW_FLAG_BSCROLLING);
		}
		hmi->evt.type = BCHANLHMIEVENT_TYPE_EXTERNALBBSWINDOW_SCROLL;
		hmi->evt.data.externalbbswindow_scroll.dh = dh;
		hmi->evt.data.externalbbswindow_scroll.dv = dv;
		return True;
	}
	if (subjectoptionwindow_issetflag(hmi->subjectoptionwindow, SUBJECTOPTIONWINDOW_FLAG_PARTS_OTHEREVENT) == True) {
		subjectoptionwindow_clearflag(hmi->subjectoptionwindow, SUBJECTOPTIONWINDOW_FLAG_PARTS_OTHEREVENT);
		subjectoptionwindow_setflag(hmi->subjectoptionwindow, SUBJECTOPTIONWINDOW_FLAG_PARTS_NEXTACTION);
		return False;
	} else if (subjectoptionwindow_issetflag(hmi->subjectoptionwindow, SUBJECTOPTIONWINDOW_FLAG_PARTS_NEXTACTION) == True) {
		subjectoptionwindow_clearflag(hmi->subjectoptionwindow, SUBJECTOPTIONWINDOW_FLAG_PARTS_NEXTACTION);
		if (hmi->subjectoptionwindow->filter.nextaction == True) {
			hmi->wev.s.type = EV_NULL;
			subjectoptionwindow_actionfilter(hmi->subjectoptionwindow, &hmi->wev, &hmi->evt);
			return True;
		}
	}
	if (registerexternalwindow_issetflag(hmi->registerexternalwindow, REGISTEREXTERNALWINDOW_FLAG_PARTS_OTHEREVENT) == True) {
		registerexternalwindow_clearflag(hmi->registerexternalwindow, REGISTEREXTERNALWINDOW_FLAG_PARTS_OTHEREVENT);
		registerexternalwindow_setflag(hmi->registerexternalwindow, REGISTEREXTERNALWINDOW_FLAG_PARTS_NEXTACTION);
		return False;
	} else if (registerexternalwindow_issetflag(hmi->registerexternalwindow, REGISTEREXTERNALWINDOW_FLAG_PARTS_NEXTACTION) == True) {
		registerexternalwindow_clearflag(hmi->registerexternalwindow, REGISTEREXTERNALWINDOW_FLAG_PARTS_NEXTACTION);
		if (hmi->registerexternalwindow->boradname.nextaction == True) {
			hmi->wev.s.type = EV_NULL;
			registerexternalwindow_actionboradname(hmi->registerexternalwindow, &hmi->wev, &hmi->evt);
			return True;
		}
		if (hmi->registerexternalwindow->url.nextaction == True) {
			hmi->wev.s.type = EV_NULL;
			registerexternalwindow_actionurl(hmi->registerexternalwindow, &hmi->wev, &hmi->evt);
			return True;
		}
	}

	return False;
}

EXPORT W bchanlhmi_getevent(bchanlhmi_t *hmi, bchanlhmievent_t **evt)
{
	WEVENT	*wev0;
	Bool ok;

	hmi->evt.type = BCHANLHMIEVENT_TYPE_NONE;
	*evt = &hmi->evt;
	wev0 = &hmi->wev;

	ok = bchanlhmi_issetswitchbutdnflag(hmi);
	if (ok == True) {
		bchanlhmi_weventbutdn(hmi, wev0, &hmi->evt);
		bchanlhmi_clearswitchbutdnflag(hmi);
		return 0;
	}

	if (subjectwindow_issetflag(hmi->subjectwindow, SUBJECTWINDOW_FLAG_DRAWREQUEST) == True) {
		hmi->evt.type = BCHANLHMIEVENT_TYPE_SUBJECTWINDOW_DRAW;
		subjectwindow_clearflag(hmi->subjectwindow, SUBJECTWINDOW_FLAG_DRAWREQUEST);
		return 0;
	}
	if (bbsmenuwindow_issetflag(hmi->bbsmenuwindow, BBSMENUWINDOW_FLAG_DRAWREQUEST) == True) {
		hmi->evt.type = BCHANLHMIEVENT_TYPE_BBSMENUWINDOW_DRAW;
		bbsmenuwindow_clearflag(hmi->bbsmenuwindow, BBSMENUWINDOW_FLAG_DRAWREQUEST);
		return 0;
	}
	if (subjectoptionwindow_issetflag(hmi->subjectoptionwindow, SUBJECTOPTIONWINDOW_FLAG_DRAWREQUEST) == True) {
		subjectoptionwindow_redisp(hmi->subjectoptionwindow);
		subjectoptionwindow_clearflag(hmi->subjectoptionwindow, SUBJECTOPTIONWINDOW_FLAG_DRAWREQUEST);
		return 0;
	}
	if (registerexternalwindow_issetflag(hmi->registerexternalwindow, REGISTEREXTERNALWINDOW_FLAG_DRAWREQUEST) == True) {
		registerexternalwindow_redisp(hmi->registerexternalwindow);
		registerexternalwindow_clearflag(hmi->registerexternalwindow, REGISTEREXTERNALWINDOW_FLAG_DRAWREQUEST);
		return 0;
	}
	if (externalbbswindow_issetflag(hmi->externalbbswindow, EXTERNALBBSWINDOW_FLAG_DRAWREQUEST) == True) {
		hmi->evt.type = BCHANLHMIEVENT_TYPE_EXTERNALBBSWINDOW_DRAW;
		externalbbswindow_clearflag(hmi->externalbbswindow, EXTERNALBBSWINDOW_FLAG_DRAWREQUEST);
		return 0;
	}

	ok = bchanlhmi_checkflag(hmi, evt);
	if (ok == True) {
		return 0;
	}

	wget_evt(wev0, WAIT);
	switch (wev0->s.type) {
	case	EV_NULL:
		bchanlhmi_weventnull(hmi, wev0, &hmi->evt);
		break;
	case	EV_REQUEST:
		bchanlhmi_weventrequest(hmi, wev0, &hmi->evt);
		break;
	case	EV_RSWITCH:
		bchanlhmi_weventreswitch(hmi, wev0, &hmi->evt);
		break;
	case	EV_SWITCH:
		bchanlhmi_weventswitch(hmi, wev0, &hmi->evt);
		break;
	case	EV_BUTDWN:
		bchanlhmi_weventbutdn(hmi, wev0, &hmi->evt);
		break;
	case	EV_KEYDWN:
	case	EV_AUTKEY:
		hmi->evt.type = BCHANLHMIEVENT_TYPE_COMMON_KEYDOWN;
		hmi->evt.data.common_keydown.keycode = wev0->e.data.key.code;
		hmi->evt.data.common_keydown.keytop = wev0->e.data.key.keytop;
		hmi->evt.data.common_keydown.stat = wev0->e.stat;
		break;
	case	EV_INACT:
		pdsp_msg(NULL);
		break;
	case	EV_DEVICE:
		oprc_dev(&wev0->e, NULL, 0);
		break;
	case	EV_MSG:
		bchanlhmi_receivemessage(hmi, &hmi->evt);
		break;
	case	EV_MENU:
		hmi->evt.type = BCHANLHMIEVENT_TYPE_COMMON_MENU;
		hmi->evt.data.common_menu.pos = wev0->s.pos;
		break;
	}

	return 0;
}

EXPORT subjectwindow_t* subjectwindow_new(RECT *r, WID parent, TC *title, PAT *bgpat)
{
	subjectwindow_t *window;
	W err;

	window = (subjectwindow_t*)malloc(sizeof(subjectwindow_t));
	if (window == NULL) {
		return NULL;
	}
	window->flag = 0;
	window->wid = -1;
	window->gid = -1;
	window->parent = parent;
	window->r = *r;
	err = hmi_windowscroll_initialize(&window->wscr, window->wid);
	if (err < 0) {
		free(window);
		return NULL;
	}

	err = subjectwindow_open(window, title);
	if (err < 0) {
		hmi_windowscroll_finalize(&window->wscr);
		free(window);
		return NULL;
	}

	return window;
}

LOCAL VOID subjectwindow_delete(subjectwindow_t *window)
{
	if (window->wid > 0) {
		wcls_wnd(window->wid, CLR);
	}
	hmi_windowscroll_finalize(&window->wscr);
	free(window);
}

EXPORT bbsmenuwindow_t* bbsmenuwindow_new(RECT *r, WID parent, TC *title, PAT *bgpat)
{
	bbsmenuwindow_t *window;
	W err;

	window = (bbsmenuwindow_t*)malloc(sizeof(bbsmenuwindow_t));
	if (window == NULL) {
		return NULL;
	}
	window->flag = 0;
	window->wid = -1;
	window->gid = -1;
	window->parent = parent;
	window->r = *r;
	err = hmi_windowscroll_initialize(&window->wscr, window->wid);
	if (err < 0) {
		free(window);
		return NULL;
	}

	err = bbsmenuwindow_open(window, title);
	if (err < 0) {
		hmi_windowscroll_finalize(&window->wscr);
		free(window);
		return NULL;
	}

	return window;
}

LOCAL VOID bbsmenuwindow_delete(bbsmenuwindow_t *window)
{
	if (window->wid > 0) {
		wcls_wnd(window->wid, CLR);
	}
	hmi_windowscroll_finalize(&window->wscr);
	free(window);
}

EXPORT subjectoptionwindow_t* subjectoptionwindow_new(PNT *p, subjectwindow_t *parent, TC *title, PAT *bgpat, W dnum_filter, W dnum_order, W dnum_orderby)
{
	subjectoptionwindow_t *window;

	window = (subjectoptionwindow_t*)malloc(sizeof(subjectoptionwindow_t));
	if (window == NULL) {
		return NULL;
	}
	window->wid = -1;
	window->gid = -1;
	window->parent = parent;
	window->r.c.left = p->x;
	window->r.c.top = p->y;
	window->r.c.right = p->x + 384;
	window->r.c.bottom = p->y + 160;
	tc_strset(window->title, TNULL, 256+1);
	if (title != 0) {
		tc_strncpy(window->title, title, 256);
	} else {
		window->title[0] = 0x2539;
		window->title[1] = 0x256c;
		window->title[2] = 0x306c;
		window->title[3] = 0x4d77;
		window->title[4] = 0x405f;
		window->title[5] = 0x446a;
	}
	window->filter.id = -1;
	window->filter.dnum = dnum_filter;
	memset(window->filter.buf, 0, sizeof(TC)*1000);
	window->filter.buf[0] = MC_ATTR;
	*(COLOR*)(window->filter.buf + 1) = -1;
	window->filter.buf[3] = -1;
	window->filter.buf[4] = 0;
	window->filter.buf[5] = 16;
	window->filter.buf[6] = 16;
	window->filter.buf[7] = TNULL;
	window->filter.nextaction = False;
	window->order.id = -1;
	window->order.dnum = dnum_order;
	window->order.value = 0;
	window->orderby.id = -1;
	window->orderby.dnum = dnum_orderby;
	window->orderby.value = 0;


	return window;
}

LOCAL VOID subjectoptionwindow_delete(subjectoptionwindow_t *window)
{
	if (window->wid > 0) {
		cdel_pwd(window->wid, NOCLR);
		wcls_wnd(window->wid, CLR);
	}
	free(window);
}

EXPORT registerexternalwindow_t* registerexternalwindow_new(PNT *p, WID parent, TC *title, PAT *bgpat)
{
	registerexternalwindow_t *window;

	window = (registerexternalwindow_t*)malloc(sizeof(registerexternalwindow_t));
	if (window == NULL) {
		return NULL;
	}
	window->wid = -1;
	window->gid = -1;
	window->parent = parent;
	window->r.c.left = p->x;
	window->r.c.top = p->y;
	window->r.c.right = p->x + 384;
	window->r.c.bottom = p->y + 138;
	tc_strset(window->title, TNULL, 256+1);
	if (title != 0) {
		tc_strncpy(window->title, title, 256);
	} else {
		window->title[0] = 0x3330;
		window->title[1] = 0x4974;
		window->title[2] = 0x4844;
		window->title[3] = 0x244e;
		window->title[4] = 0x4449;
		window->title[5] = 0x3243;
	}
	window->boradname.id = -1;
	memset(window->boradname.buf, 0, sizeof(TC)*1000);
	window->boradname.buf[0] = MC_ATTR;
	*(COLOR*)(window->boradname.buf + 1) = -1;
	window->boradname.buf[3] = -1;
	window->boradname.buf[4] = 0;
	window->boradname.buf[5] = 16;
	window->boradname.buf[6] = 16;
	window->boradname.buf[7] = TNULL;
	window->boradname.nextaction = False;
	window->url.id = -1;
	memset(window->url.buf, 0, sizeof(TC)*1000);
	window->url.buf[0] = MC_ATTR;
	*(COLOR*)(window->url.buf + 1) = -1;
	window->url.buf[3] = -1;
	window->url.buf[4] = 0;
	window->url.buf[5] = 8;
	window->url.buf[6] = 16;
	window->url.buf[7] = TNULL;
	window->url.nextaction = False;
	window->determine.id = -1;
	window->cancel.id = -1;


	return window;
}

LOCAL VOID registerexternalwindow_delete(registerexternalwindow_t *window)
{
	if (window->wid > 0) {
		cdel_pwd(window->wid, NOCLR);
		wcls_wnd(window->wid, CLR);
	}
	free(window);
}

EXPORT externalbbswindow_t* externalbbswindow_new(RECT *r, WID parent, TC *title, PAT *bgpat)
{
	externalbbswindow_t *window;
	W err;

	window = (externalbbswindow_t*)malloc(sizeof(externalbbswindow_t));
	if (window == NULL) {
		return NULL;
	}
	window->flag = 0;
	window->wid = -1;
	window->gid = -1;
	window->parent = parent;
	window->r = *r;
	err = hmi_windowscroll_initialize(&window->wscr, window->wid);
	if (err < 0) {
		free(window);
		return NULL;
	}
	tc_strset(window->title, TNULL, 256+1);
	if (title != 0) {
		tc_strncpy(window->title, title, 256);
	} else {
		window->title[0] = 0x3330;
		window->title[1] = 0x4974;
		window->title[2] = 0x4844;
	}


	return window;
}

LOCAL VOID externalbbswindow_delete(externalbbswindow_t *window)
{
	if (window->wid > 0) {
		wcls_wnd(window->wid, CLR);
	}
	hmi_windowscroll_finalize(&window->wscr);
	free(window);
}

EXPORT subjectwindow_t* bchanlhmi_newsubjectwindow(bchanlhmi_t *hmi, RECT *r, WID parent, TC *title, PAT *bgpat)
{
	if (hmi->subjectwindow != NULL) {
		return NULL;
	}
	hmi->subjectwindow = subjectwindow_new(r, parent, title, bgpat);
	return hmi->subjectwindow;
}

EXPORT VOID bchanlhmi_deletesubjectwindow(bchanlhmi_t *hmi, subjectwindow_t *window)
{
	subjectwindow_delete(hmi->subjectwindow);
	hmi->subjectwindow = NULL;
}

EXPORT bbsmenuwindow_t* bchanlhmi_newbbsmenuwindow(bchanlhmi_t *hmi, RECT *r, WID parent, TC *title, PAT *bgpat)
{
	if (hmi->bbsmenuwindow != NULL) {
		return NULL;
	}
	hmi->bbsmenuwindow = bbsmenuwindow_new(r, parent, title, bgpat);
	return hmi->bbsmenuwindow;
}

EXPORT VOID bchanlhmi_deletebbsmenuwindow(bchanlhmi_t *hmi, bbsmenuwindow_t *window)
{
	bbsmenuwindow_delete(hmi->bbsmenuwindow);
	hmi->bbsmenuwindow = NULL;
}

EXPORT subjectoptionwindow_t* bchanlhmi_newsubjectoptionwindow(bchanlhmi_t *hmi, PNT *p, subjectwindow_t *parent, TC *title, PAT *bgpat, W dnum_filter, W dnum_order, W dnum_orderby)
{
	if (parent == NULL) {
		return NULL;
	}
	if (hmi->subjectoptionwindow != NULL) {
		return NULL;
	}
	hmi->subjectoptionwindow = subjectoptionwindow_new(p, parent, title, bgpat, dnum_filter, dnum_order, dnum_orderby);
	return hmi->subjectoptionwindow;
}

EXPORT VOID bchanlhmi_deletesubjectoptionwindow(bchanlhmi_t *hmi, subjectoptionwindow_t *window)
{
	subjectoptionwindow_delete(hmi->subjectoptionwindow);
	hmi->subjectoptionwindow = NULL;
}

EXPORT registerexternalwindow_t* bchanlhmi_newregisterexternalwindow(bchanlhmi_t *hmi, PNT *p, WID parent, TC *title, PAT *bgpat)
{
	if (hmi->registerexternalwindow != NULL) {
		return NULL;
	}
	hmi->registerexternalwindow = registerexternalwindow_new(p, parent, title, bgpat);
	return hmi->registerexternalwindow;
}

EXPORT VOID bchanlhmi_deleteregisterexternalwindow(bchanlhmi_t *hmi, registerexternalwindow_t *window)
{
	registerexternalwindow_delete(hmi->registerexternalwindow);
	hmi->registerexternalwindow = NULL;
}

EXPORT externalbbswindow_t* bchanlhmi_newexternalbbswindow(bchanlhmi_t *hmi, RECT *r, WID parent, TC *title, PAT *bgpat)
{
	if (hmi->externalbbswindow != NULL) {
		return NULL;
	}
	hmi->externalbbswindow = externalbbswindow_new(r, parent, title, bgpat);
	return hmi->externalbbswindow;
}

EXPORT VOID bchanlhmi_deleteexternalbbswindow(bchanlhmi_t *hmi, externalbbswindow_t *window)
{
	externalbbswindow_delete(hmi->externalbbswindow);
	hmi->externalbbswindow = NULL;
}


EXPORT bchanlhmi_t* bchanlhmi_new()
{
	bchanlhmi_t *hmi;

	hmi = (bchanlhmi_t *)malloc(sizeof(bchanlhmi_t));
	if (hmi == NULL) {
		return NULL;
	}
	hmi->flag = 0;
	hmi->subjectwindow = NULL;
	hmi->bbsmenuwindow = NULL;
	hmi->subjectoptionwindow = NULL;
	hmi->registerexternalwindow = NULL;
	hmi->externalbbswindow = NULL;

	return hmi;
}

EXPORT VOID bchanlhmi_delete(bchanlhmi_t *hmi)
{
	if (hmi->subjectwindow != NULL) {
		subjectwindow_delete(hmi->subjectwindow);
	}
	if (hmi->bbsmenuwindow != NULL) {
		bbsmenuwindow_delete(hmi->bbsmenuwindow);
	}
	if (hmi->subjectoptionwindow != NULL) {
		subjectoptionwindow_delete(hmi->subjectoptionwindow);
	}
	if (hmi->registerexternalwindow != NULL) {
		registerexternalwindow_delete(hmi->registerexternalwindow);
	}
	if (hmi->externalbbswindow != NULL) {
		externalbbswindow_delete(hmi->externalbbswindow);
	}
	free(hmi);
}
